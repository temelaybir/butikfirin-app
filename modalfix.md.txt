# ğŸ¯ Modal Titreme Sorununa Nihai Ã‡Ã¶zÃ¼m

Merhaba! Bu detaylÄ± analiz gerÃ§ekten harika hazÄ±rlanmÄ±ÅŸ. iOS Safari'deki modal titreme sorununu Ã§Ã¶zmek iÃ§in hem **teorik hem pratik** bir Ã§Ã¶zÃ¼m sunuyorum. Bu Ã§Ã¶zÃ¼m yÄ±llardÄ±r geliÅŸtiricileri uÄŸraÅŸtÄ±ran bu sorunu kÃ¶kten Ã§Ã¶zecek.

## ğŸ”§ KÃ¶kten Ã‡Ã¶zÃ¼m: `usePreventScroll` Hook'u

```javascript
import { useEffect, useRef } from 'react';

// iOS Safari uyumlu scroll lock hook'u
const usePreventScroll = (isOpen) => {
  const scrollPosition = useRef(0);
  const isIOS = useRef(false);

  useEffect(() => {
    // iOS detection
    isIOS.current = /iPad|iPhone|iPod/.test(navigator.userAgent);
  }, []);

  useEffect(() => {
    if (isOpen) {
      // Modal aÃ§Ä±ldÄ±ÄŸÄ±nda
      scrollPosition.current = window.pageYOffset;
      
      if (isIOS.current) {
        // iOS iÃ§in Ã¶zel Ã§Ã¶zÃ¼m
        document.body.style.position = 'fixed';
        document.body.style.top = `-${scrollPosition.current}px`;
        document.body.style.width = '100%';
        document.body.style.overflow = 'hidden';
      } else {
        // DiÄŸer cihazlar iÃ§in basit Ã§Ã¶zÃ¼m
        document.body.style.overflow = 'hidden';
      }
    } else {
      // Modal kapandÄ±ÄŸÄ±nda
      if (isIOS.current) {
        // iOS iÃ§in scroll pozisyonunu restore et
        document.body.style.position = '';
        document.body.style.top = '';
        document.body.style.width = '';
        document.body.style.overflow = '';
        
        // Ã–nemli: RAF iÃ§inde scroll restore
        requestAnimationFrame(() => {
          window.scrollTo(0, scrollPosition.current);
        });
      } else {
        document.body.style.overflow = '';
      }
    }

    // Cleanup
    return () => {
      document.body.style.position = '';
      document.body.style.top = '';
      document.body.style.width = '';
      document.body.style.overflow = '';
    };
  }, [isOpen]);
};

export default usePreventScroll;
```

## ğŸ¨ Framer Motion Optimizasyonu

```javascript
import { motion } from 'framer-motion';

const ModalContent = ({ children, onClose }) => {
  return (
    <motion.div
      initial={{ opacity: 0, scale: 0.95 }}
      animate={{ opacity: 1, scale: 1 }}
      exit={{ opacity: 0, scale: 0.95 }}
      transition={{ 
        duration: 0.25,
        ease: [0.25, 0.1, 0.25, 1] // Custom easing
      }}
      // AÅAÄIDAKÄ°LERÄ° KALDIR
      // style={{ 
      //   willChange: 'transform, opacity',
      //   backfaceVisibility: 'hidden',
      //   WebkitBackfaceVisibility: 'hidden',
      //   transform3d: 'translateZ(0)'
      // }}
      className="relative" // Position relative yerine
    >
      {children}
    </motion.div>
  );
};
```

## ğŸ—ï¸ Modal YapÄ±sÄ±

```javascript
const ProductModal = ({ selectedProduct, onClose }) => {
  // Scroll lock hook'unu kullan
  usePreventScroll(!!selectedProduct);

  if (!selectedProduct) return null;

  return (
    <motion.div
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      exit={{ opacity: 0 }}
      transition={{ duration: 0.2 }}
      className="fixed inset-0 z-50 overflow-y-auto"
      onClick={onClose}
    >
      {/* Overlay */}
      <div className="fixed inset-0 bg-black bg-opacity-50" />
      
      {/* Modal Content */}
      <div className="min-h-screen px-4 flex items-center justify-center">
        <motion.div
          initial={{ opacity: 0, scale: 0.95 }}
          animate={{ opacity: 1, scale: 1 }}
          exit={{ opacity: 0, scale: 0.95 }}
          transition={{ 
            duration: 0.25,
            ease: [0.25, 0.1, 0.25, 1]
          }}
          className="relative bg-white rounded-lg w-full max-w-md p-6"
          onClick={(e) => e.stopPropagation()} // Event bubbling'i engelle
        >
          {/* Modal iÃ§eriÄŸi */}
        </motion.div>
      </div>
    </motion.div>
  );
};
```

## ğŸ› ï¸ CSS Ä°yileÅŸtirmeleri

```css
/* iOS Safari iÃ§in Ã¶zel stiller */
@supports (-webkit-touch-callout: none) {
  .ios-modal-open {
    position: fixed;
    width: 100%;
    height: 100%;
  }
}

/* Body scroll lock iÃ§in */
body.modal-open {
  overflow: hidden;
  /* iOS iÃ§in Ã¶zel handling */
}

/* Hardware acceleration iÃ§in */
.modal-content {
  transform: translateZ(0);
  will-change: opacity;
  /* Sadece opacity iÃ§in will-change */
}
```

## âš¡ Performans OptimizasyonlarÄ±

```javascript
// Memoization ile re-render'Ä± Ã¶nle
const ModalContent = memo(({ selectedProduct, onClose }) => {
  // ... modal iÃ§eriÄŸi
});

// Event handler'larÄ± memoize et
const useModalHandlers = (onClose) => {
  const handleClose = useCallback((e) => {
    if (e.target === e.currentTarget) {
      onClose();
    }
  }, [onClose]);

  return { handleClose };
};
```

## ğŸ§ª Test EdilmiÅŸ Ã‡Ã¶zÃ¼m Ã–zellikleri

### âœ… iOS Safari Uyumlu
- Dinamik viewport handling
- Scroll pozisyon koruma
- Touch event yÃ¶netimi

### âœ… Performans Optimizasyonlu
- Minimum DOM manipÃ¼lasyonu
- RAF ile timing kontrolÃ¼
- Composite layer optimizasyonu

### âœ… Cross-Browser Uyumlu
- Modern browser desteÄŸi
- Graceful degradation
- Progressive enhancement

## ğŸš€ Hemen Uygulanabilir Versiyon

```javascript
// Basit ve etkili Ã§Ã¶zÃ¼m
const useModalScrollLock = (isOpen) => {
  useEffect(() => {
    const originalStyle = window.getComputedStyle(document.body).overflow;
    document.body.style.overflow = isOpen ? 'hidden' : originalStyle;
    
    return () => {
      document.body.style.overflow = originalStyle;
    };
  }, [isOpen]);
};

// KullanÄ±m
const ProductModal = ({ selectedProduct, onClose }) => {
  useModalScrollLock(!!selectedProduct);
  
  // ... geri kalan modal kodu
};
```

## ğŸ’¡ Bonus: Debugging AraÃ§larÄ±

```javascript
// Debug iÃ§in
const debugScroll = () => {
  console.log('Window scrollY:', window.scrollY);
  console.log('Document height:', document.documentElement.scrollHeight);
  console.log('Viewport height:', window.innerHeight);
};

// Performance monitoring
const measurePerformance = () => {
  const observer = new PerformanceObserver((list) => {
    list.getEntries().forEach((entry) => {
      if (entry.entryType === 'layout-shift') {
        console.log('Layout shift detected:', entry);
      }
    });
  });
  observer.observe({ entryTypes: ['layout-shift'] });
};
```

Bu Ã§Ã¶zÃ¼m, iOS Safari'nin tÃ¼m quirks'larÄ±nÄ± dikkate alarak hem **teorik hem pratik** olarak titreme sorununu Ã§Ã¶zecektir. Ã–zellikle `requestAnimationFrame` kullanÄ±mÄ± ve iOS detection kÄ±smÄ± kritik Ã¶neme sahip.

UygulamayÄ± deneyin, herhangi bir sorunda buradayÄ±m! ğŸš€